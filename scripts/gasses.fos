#ifndef GASSES
#define GASSES

#include "_utils.fos"
#include "gasses_h.fos"
#include "repair_h.fos"

import uint CountMapPlayers( Map@ map ) from "manager";

//~run gasses test gas_type 0 0
void test( Critter& cr, int gas_type, int used_air, int )
{
	string breathing = flagValue( canBreathe( cr, gas_type ), WHITE + "can", RED + "can't" ) + GREEN + " breathe";
	string protection = flagValue( hasProtection( cr ), WHITE + "have", RED + "haven't" ) + GREEN + " protection";
	string mask = flagValue( CheckGasMask( cr ), WHITE + "have", RED + "haven't" ) + GREEN + " gas mask";
	string tank = flagValue( CheckAirTank( cr ), WHITE + "have", RED + "haven't" ) + GREEN + " air tank";
	string filter = flagValue( CheckAirFilter( cr ), WHITE + "have", RED + "haven't" ) + GREEN + " filter";
	cr.Say( SAY_NETMSG, "You " + breathing + ", " + protection + ": " + mask + ", " + tank + ", " + filter + "." );
	UseAirTank( cr, used_air );
}

string[] gas_type_names = { "respirator", "no oxygen" };
string gasTypeName( int type )
{
	return gas_type_names[ CLAMP( uint(type), 0, gas_type_names.length() ) ];
}

void GasHex( Critter& cr, int mapID, int hx, int hy, int gas_strength, int gas_time, int gas_radius, int gas_type )
{
	if( gas_strength < 0 || gas_time < 0 || gas_radius < 0 )
	{
		return;
	}
	
	Map@ map = GetMap( mapID );
	if( !valid( map ) )
	{
		return;
	}
	
	Item@ gasMarker = map.AddItem( hx, hy, PID_GAS_MARKER, 1 );
	if( valid( gasMarker ) )
	{
		gasMarker.GAS_STRENGTH = gas_strength;
		gasMarker.GAS_TICK = gas_time;
		gasMarker.GAS_DISTANCE = gas_radius;
		gasMarker.GAS_TYPE = gas_type;
		gasMarker.Update();
		
		uint[] values = { gasMarker.Id };
		gasMarker.GAS_EVENT = CreateTimeEvent( __FullSecond, "gasses@e_gasFlow", values, true );
		cr.Say( SAY_NETMSG, "The [" + gasTypeName(gas_type) + "] Gas source set at X: " + hx + " Y: " + hy + " , strength: "+ gas_strength + " , tick: "+ gas_time + " minutes, radius: " + gas_radius + " hex " );
	}
}

uint e_gasFlow( uint[]@ values )
{
    Item@ gasMarker = GetItem( values[0] );

    if( !valid( gasMarker ) )
	{
		return 0;
	}
	
	Map@ map = GetMap( gasMarker.MapId );
    if( !valid( map ) )
	{
		DeleteItem( gasMarker );
		return 0;
	}
	
	if( CountMapPlayers( map ) == 0 )
	{
		return REAL_SECOND( gasMarker.GAS_TICK );
	}
	
	Critter@[] critters;
    uint count = map.GetCrittersHex( gasMarker.HexX, gasMarker.HexY, gasMarker.GAS_DISTANCE, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, critters );
	if( count > 0 )
	{
		for( uint i = 0; i < count; i++ )
		{
			DypsneaCr( critters[i], gasMarker.GAS_STRENGTH, gasMarker.GAS_TYPE );
		}
	}
	
	return REAL_SECOND( gasMarker.GAS_TICK );
}

void DypsneaCr( Critter& cr, uint rate, uint type )
{
	uint[] indexes;
	uint[] durations;
	if( cr.GetTimeEvents( CTE_DYSPNEA, indexes, durations, null ) > 0 )
	{
		if( rate > 0 )
		{
			if( isGM( cr ) )
			{		
				return;
			}
			cr.ChangeTimeEvent( indexes[0], 0, rate );
		}
	}
	else
	{
		switch( type )
		{
			case GAS_TYPE_DEFAULT: 	cr.AddTimeEvent( "gasses@cte_Dyspnea", 0, CTE_DYSPNEA, rate ); break;
			case GAS_TYPE_NO_OXYGEN:	cr.AddTimeEvent( "gasses@cte_NoOxygen", 0, CTE_DYSPNEA, rate ); break;
		}		
	}
}

uint cte_Dyspnea( Critter& cr, int identifier, uint& rate )
{
	return process_dyspnea( cr, rate, GAS_TYPE_DEFAULT );
}
	
uint cte_NoOxygen( Critter& cr, int identifier, uint& rate )
{
	return process_dyspnea( cr, rate, GAS_TYPE_NO_OXYGEN );
}

bool canBreathe( Critter& cr, uint gas_type )
{
	if( gas_type == GAS_TYPE_DEFAULT && CheckGasMask( cr ) )
	{
		return true;
	}

	if( CheckAirTank( cr ) || CheckAirFilter( cr ) ) //allows to ignore all types of gas markers
	{
		return true;
	}
	
	return false;
}

uint process_dyspnea( Critter& cr, uint& rate, uint gas_type )
{
	bool freshAir = ( rate <= 0 );
	if( freshAir || canBreathe( cr, gas_type ) )
	{		
		return take_breath( cr, rate, freshAir );
	}
	
	return suffocation_progress( cr, rate );
}

uint suffocation_progress( Critter& cr, uint& rate )
{
	cr.StatBase[ ST_DYSPNEA ] += rate;
	rate = 0;
	
    return REAL_SECOND( 10 );
}

uint take_breath( Critter& cr, uint& rate, bool freshAir )
{
	if( !freshAir )
	{
		UseAirTank( cr );
	}
	
	cr.StatBase[ ST_DYSPNEA ] -= cr.Stat[ ST_ENDURANCE ] * 10;
	rate = 0;
	
	if ( cr.StatBase[ ST_DYSPNEA ] <= 0 ) 
	{
		return 0;
	}
	
	return REAL_SECOND( 10 );
}

bool hasProtection( Critter& cr )
{
	return CheckGasMask( cr ) || CheckAirTank( cr ) || CheckAirFilter( cr );
}

bool CheckGasMask( Critter& cr )
{
	Item@ respirator = _CritGetItemHead( cr );
	if( valid( respirator ) )
	{
		uint det = GetDeteriorationProcent( respirator );
		if( det < 5 && FLAG( respirator.Proto.Item_Perk, HEAD_PERK_GASMASK ) )
		{
			return true;
		}
	}
	return false;
}

bool CheckAirTank( Critter& cr )
{
	Item@ item = _CritGetItemBack( cr );
	if( valid( item ) && FLAG( item.Proto.Item_Perk, BACK_PERK_AIR_TANK ) )
	{		
		uint air = 100 - GetDeteriorationProcent( item );
		return air > 0;
	}
	return false;
}

void UseAirTank( Critter& cr, int used_air = 1 )
{
	Item@ item = _CritGetItemBack( cr );
	if( valid( item ) && FLAG( item.Proto.Item_Perk, BACK_PERK_AIR_TANK ) )
	{		
		uint det = GetDeteriorationProcent( item );
		SetDeterioration( item, det + used_air );
	}
}
	
bool CheckAirFilter( Critter& cr )
{
	Item@ armor = _CritGetItemArmor( cr );
	if( valid( armor ) )
	{
		uint det = GetDeteriorationProcent( armor );
		if( det < 5 && FLAG( armor.Proto.Armor_Perk, ARMOR_PERK_AIR_FILTER ) )
		{
			return true;			
		}
	}	
	return false;
}

#endif // GASSES